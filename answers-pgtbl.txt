问题1：哪些系统调用可以通过共享页面加速？
可以加速的系统调用：

pipe() 系统调用
// 当前实现：通过内核缓冲区传输数据
write(pipe_fd, data, size) → 内核缓冲区 → read(pipe_fd, buf, size)
// 优化方案：共享页面
// 写进程和读进程共享同一个物理页面，减少数据拷贝

fork() 系统调用
// 当前：Copy-on-Write (COW)
// 优化：父子进程可以共享更多只读页面（如代码段）

exec() 系统调用
// 当前：加载程序需要分配新页面并拷贝数据
// 优化：多个相同程序可以共享代码页面

消息传递相关的系统调用
// 大数据传输时，可以通过共享页面避免数据拷贝

问题2：根据教材图3-4来解释vmprint的输出。页面0包含什么？页面2中有什么？当在用户模式下运行时，进程能否读写页面1映射的内存？倒数第三个页面包含什么？
让我详细解答：
根据图3-4解释vmprint输出
典型的vmprint输出示例：
page table 0x87f6e000
..0: pte 0x21fda801 pa 0x87f6a000
.. ..0: pte 0x21fda401 pa 0x87f69000  
.. .. ..0: pte 0x21fdac1f pa 0x87f6b000  ← 页面0
.. .. ..1: pte 0x21fda01f pa 0x87f68000  ← 页面1  
.. .. ..2: pte 0x21fda41f pa 0x87f69000  ← 页面2
.. .. ..253: pte 0x20001c0b pa 0x80007000 ← 倒数第三页
.. .. ..254: pte 0x20001007 pa 0x80004000 ← trapframe
.. .. ..255: pte 0x20001003 pa 0x80004000 ← trampoline

页面内容分析：
1. 页面0包含什么？
// 虚拟地址：0x0000 - 0x0fff
// 内容：程序的代码段（text segment）开始部分
// - 包含程序的机器指令
// - ELF文件的代码部分被加载到这里
// - 通常是只读和可执行的

2. 页面2包含什么？
// 虚拟地址：0x2000 - 0x2fff  
// 内容：程序的数据段（data segment）
// - 包含已初始化的全局变量
// - 包含字符串常量
// - 可读写，不可执行

3. 用户模式能否读写页面1？
// 需要检查页面1的PTE权限位
pte_t pte1 = 0x21fda01f;  // 页面1的PTE

// 权限位分析：
// 最低几位：...00011111
// PTE_V = 1 (有效)
// PTE_R = 1 (可读) 
// PTE_W = 1 (可写)
// PTE_X = 1 (可执行)
// PTE_U = 1 (用户可访问)

// 结论：用户模式可以读写页面1
if(pte1 & PTE_U) {
    printf("用户模式可以访问\n");
    if(pte1 & PTE_R) printf("可读\n");
    if(pte1 & PTE_W) printf("可写\n");
}

4. 倒数第三个页面包含什么？
// 根据xv6的内存布局（图3-4）：
// 最后三个页面通常是：
// 255: trampoline (陷阱跳转代码)
// 254: trapframe  (陷阱帧) 
// 253: 用户栈的顶部页面

// 所以倒数第三页（253）包含：
// - 用户栈的一部分
// - 函数调用的栈帧
// - 局部变量
// - 返回地址等

结合图3-4的完整解释：
xv6进程虚拟地址空间布局：

MAXVA → ┌─────────────────┐
        │   trampoline    │ ← 页面255：内核陷阱处理代码
        ├─────────────────┤
        │   trapframe     │ ← 页面254：保存用户寄存器
        ├─────────────────┤  
        │   user stack    │ ← 页面253：用户栈（倒数第三页）
        │       ↓         │
        ├─────────────────┤
        │      ...        │ ← 未使用的虚拟地址空间
        ├─────────────────┤
        │       ↑         │
        │     heap        │ ← 堆区域（动态分配）
        ├─────────────────┤
        │     data        │ ← 页面2：数据段（全局变量）
        ├─────────────────┤
        │     text        │ ← 页面1：代码段继续
        ├─────────────────┤
    0 → │     text        │ ← 页面0：代码段开始
        └─────────────────┘

权限总结：
| 页面 |    内容     | 用户可读 | 用户可写 | 用户可执行 |
|------|------------|----------|---------|-----------|
|   0  |   代码段    |    ✓    |    ✗    |      ✓   |
|   1  |   代码段    |    ✓    |    ✗    |      ✓   |
|   2  |   数据段    |    ✓    |    ✓    |      ✗   |
|  253 |   用户栈    |    ✓    |    ✓    |      ✗   |
|  254 |  trapframe |    ✗    |    ✗    |      ✗   |
|  255 | trampoline |    ✓    |    ✗    |      ✓   |
这个分析基于xv6的典型内存布局和页表权限设置。
